# Svelte/SvelteKit Architectural Principles

Svelte and SvelteKit-specific technology choices and patterns. Apply these alongside `principles-core.md` for any Svelte project. For decomposition ordering, see `stack-patterns-svelte.md`.

## Reactivity

- **`$:` for derived state** — Use reactive declarations for values computed from other state. Do not manually track or sync derived values.
- **Avoid manual subscriptions** — Let Svelte's compiler handle reactivity. Explicit `subscribe()` calls are only needed outside `.svelte` files.
- **Runes in Svelte 5** — When targeting Svelte 5, use `$state`, `$derived`, and `$effect` runes instead of `$:` and stores. Runes are the preferred reactivity primitive.

## State Management

- **Writable stores for shared mutable state** — Use `writable()` for state shared across components. Keep stores in `src/lib/stores/`.
- **Derived stores for computations** — Use `derived()` for values computed from other stores. Never duplicate derived logic in components.
- **Custom store contract** — Any object with a `subscribe` method is a store. Use this for encapsulating complex state with controlled mutation methods.

## Component Design

- **Props for inputs** — Pass data down via props. Declare with `export let` (Svelte 4) or `$props()` (Svelte 5).
- **Events for outputs** — Communicate upward via `createEventDispatcher` (Svelte 4) or callback props (Svelte 5).
- **Slots for composition** — Use `<slot>` for component composition. Named slots for multi-region layouts.
- **Small, focused components** — Each component does one thing. If a component file exceeds ~150 lines, consider splitting.

## Validation

- **Zod at form boundaries** — Validate form data with Zod schemas in `+page.server.ts` form actions. Return structured errors.
- **Shared schemas** — Validation schemas live in `src/lib/schemas/` and are shared between client hints and server validation.

## Type Safety

- **Generated SvelteKit types** — Use `PageData`, `ActionData`, `PageServerLoad` from `./$types` auto-generated by SvelteKit. Never hand-write these.
- **`<script lang="ts">`** — All components use TypeScript. Type props, events, and store values explicitly.
- **Type-safe load functions** — Load functions (`+page.server.ts`, `+layout.server.ts`) return typed data consumed by pages via `PageData`.

## SSR Compatibility

- **No `window`/`document` at module level** — Browser globals are unavailable during SSR. Guard with `browser` from `$app/environment` or use `onMount`.
- **`onMount` for client-only code** — Side effects that require the DOM (animations, third-party libraries, event listeners) go in `onMount`.
- **Conditional imports** — Dynamically import browser-only libraries inside `onMount` or behind `if (browser)` guards.

## Testing

- **Vitest for components** — Use `@testing-library/svelte` with Vitest for component unit tests. Test rendered output and interactions.
- **Playwright for E2E** — Full user flows use Playwright. Test against the dev server or preview build.
- **Test behavior, not reactivity** — Assert on what the user sees and does, not on store values or reactive variable internals.
